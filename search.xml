<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【Python】Step Into Python Class</title>
      <link href="/2023/06/02/step-into-python-class/"/>
      <url>/2023/06/02/step-into-python-class/</url>
      
        <content type="html"><![CDATA[<h1 id="【Python】Step-Into-Python-Class"><a href="#【Python】Step-Into-Python-Class" class="headerlink" title="【Python】Step Into Python Class"></a>【Python】Step Into Python Class</h1><h2 id="Before-All"><a href="#Before-All" class="headerlink" title="Before All"></a>Before All</h2><p>Python作为一门<code>面向过程</code>兼容<code>面向对象</code>的语言，在面向对象中，使用<code>class</code>关键字来申明一个类。</p><p>But，是不是应该深入考虑一下这个<code>class</code>的底层实现过程呢？（不考虑CPython，仅仅考虑Python这一层）</p><h2 id="申明一个类"><a href="#申明一个类" class="headerlink" title="申明一个类"></a>申明一个类</h2><p>非常简单的申明方式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这样就声明了一个<code>X</code>类。</p><p>如果我们实现Java中类似<code>构造函数</code>这样的功能呢？可以使用<code>__init__</code>这个魔术方法，这个方法在类<code>创建</code>之后会被调用（这里的创建到底指的是什么，后面会谈到）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, arg1, arg2</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.arg1 = arg1</span><br><span class="line">        self.arg2 = arg2</span><br></pre></td></tr></table></figure><h3 id="经典类与新式类"><a href="#经典类与新式类" class="headerlink" title="经典类与新式类"></a>经典类与新式类</h3><p>首先，先说结论——<code>Python3中都是新式类，Python2中有新式类也有经典类</code></p><p><strong>什么是新式类？</strong></p><ul><li>继承自<code>object</code>的，都是新式类</li></ul><p><strong>什么是经典类？</strong></p><ul><li>不继承<code>object</code>的，叫作经典类</li></ul><p><strong>为什么Python3中都是新式类？</strong></p><ul><li>因为Python3中，申明一个class的时候，默认继承了<code>object</code></li></ul><p><strong>为什么Python2中有新式类也有经典类？</strong></p><ul><li>在Python2中，显式申明<code>class X(object)</code>，那么这个类就是新式类</li><li>如果没有显式申明，而是单纯的申明一个<code>class X:pass</code>，那么这个类就是经典类</li></ul><p>在<code>Python 2.1</code>之前，经典类是唯一可用的形式，在<code>Python 2.2</code>才引入了新式类。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><p>Python中想声明一个class继承了某个class，可以使用如下的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>如上的代码，<code>X</code>继承了<code>object</code>这个类，而在<code>Python3</code>中，如果没有显式申明继承<code>object</code>也没关系，默认是继承自<code>object</code>的。</p><p>但是在<code>Python2</code>中，如果不显式申明继承<code>object</code>，那么这个类就不能调用<code>object</code>中的一些属性和方法。</p><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>在Python中，可以<code>多继承</code>。这点是其他语言不兼容的（C++除外）。</p><p>很多官方的库其实都用到了多继承的特性，比如<code>socketserver</code>这个库</p><p><img src="https://img-blog.csdnimg.cn/img_convert/88e7da2d7125cda83fe0dcf2363ac093.png" alt="image-20230530101218007"></p><p>可以看到<code>ThreadingUDPServer</code>和<code>ThreadingTCPServer</code>都继承了<code>ThreadingMixIn</code>这个类，然后继承自己的父类</p><p><code>多继承</code>有好处也有坏处，好处是可以灵活运用，坏处就是如果随意使用，很难看懂代码而且会存在一些属性冲突。</p><h3 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h3><p>Mixins是一种规范，上述<code>socketserver</code>中的两个类就是使用了<code>Mixins</code>的规范：</p><ul><li>需要混入使用的特性类，写在前面，例如这个<code>ThreadingMixIn</code>，就是需要混入使用的<code>线程类</code></li><li>需要继承的父类放在最后，例如这个<code>UDPServer</code>，就是<code>ThreadingUDPServer</code>需要继承的父类</li><li>所有需要插入的Mixin特性的类以<code>MixIn</code>结尾</li></ul><p>Minins只是一种开发规范，而不是硬性规定~</p><h2 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h2><p>由于Python的多继承特性，可以引入一种新的继承模式——<code>菱形继承</code></p><p>什么是菱形继承？其实是多继承的一种特殊的形式。之所以叫作<code>菱形继承</code>是因为，形状和<code>菱形</code>类似，也可以叫作<code>钻石继承</code></p><p><img src="https://img-blog.csdnimg.cn/img_convert/9751e539dccefd773675e7b67d4cd89b.png" alt="image-20230530102815001"></p><p>转化为代码的形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>那么上述继承关系就会出现一种现象，<code>D</code>应该怎么样继承<code>B、C</code>的属性？</p><p>假设<code>B</code>和<code>C</code>都具有同一个方法<code>func1</code>，那么D调用这个方法是怎么找的呢？</p><p>我们可以查看<code>D.__mro__</code>，这个元组，或者调用<code>D.mro()</code>这个方法获取一个列表</p><blockquote><p>这里的mro是Method Resolution Order的缩写，也就是 <code>方法解析顺序</code></p></blockquote><p>无论是上述得到的元组还是列表，都存储了<code>D</code>这个类的<code>方法解析顺序</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(D.mro())</span><br><span class="line"><span class="built_in">print</span>(D.__mro__)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span></span><br><span class="line"><span class="string">(&lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>所以，<code>D</code>去查找属性或者方法的时候，就是按照这个列表的顺序往后查找，最后找公共父类<code>object</code>，如果这个列表中的所有类都没有某个属性或者方法，那么就会报错。</p><p>至于这个<code>mro</code>列表是如何生成的，在不同的Python版本，有一定的差异：</p><ul><li>经典类使用DFS</li><li>Python 2.2 的新式类使用MRO</li><li>Python 2.3 的新式类使用C3算法，同时也是Python3唯一支持的算法</li></ul><p>下面就详细说说各种版本的<code>MRO</code>方法！</p><h3 id="经典类的DFS"><a href="#经典类的DFS" class="headerlink" title="经典类的DFS"></a>经典类的DFS</h3><p>经典类的MRO方法非常简单，就是<code>从左向右的DFS</code>。</p><p>按照上述的图片，其遍历顺序是<code>[D,B,A,C,A]</code>，考虑到重复遍历跳过，那么真实的顺序是<code>[D,B,A,C]</code></p><p>但是，这样会存在什么样的问题呢？</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a23c0a559aec81b0e071cf11ce2f09f5.png" alt="image-20230530111838949"></p><p>如果按照<code>从左向右的DFS</code>顺序来进行MRO，那么我在调用<code>D.show()</code>的时候，会发生什么？</p><ul><li>由于是从左往右，先去找<code>B</code>有没有<code>show</code>，发现B没有，就去找<code>A</code></li><li>在<code>A</code>直接找到了<code>show()</code></li><li>所以<code>D</code>的对象会调用<code>A</code>中的<code>show()</code></li></ul><p>但是我们想要的效果是D去调用<code>C.show()</code>，这种MRO方式，严重违背了这种特性！</p><h3 id="新式类的BFS"><a href="#新式类的BFS" class="headerlink" title="新式类的BFS"></a>新式类的BFS</h3><p>Python2.2后，引入了<code>新式类</code>，针对新式类，有一种全新的MRO方法</p><ul><li><code>经典类</code>仍然使用<code>从左向右的DFS</code></li><li><code>新式类</code>使用<code>从左想右的BFS</code></li></ul><p>由于新式类都会继承<code>object</code>，所以之前的继承图变成了这样:</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5f6c2ed604df3a960fb9f3d1d5727a16.png" alt="image-20230530114846869"></p><p><code>从左向右的BFS</code>算法的MRO顺序就是<code>[D,B,C,A,object]</code></p><p>这样想要执行<code>D.show()</code>的时候，就可以正常继承调用<code>C.show()</code>了</p><p>但是，BFS就没有<code>特殊情况</code>吗？还是有的！</p><p><img src="https://img-blog.csdnimg.cn/img_convert/4cf04c30aa6a8d886dd4db608b3d1814.png" alt="image-20230530131330330"></p><p>翻译成代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>(B, C):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span>(C, B):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">G</span>(E, F):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li>BFS(广度优先)的结果是<code>[G, E, F, B, C, object]</code></li><li>对于<code>F</code>，搜索顺序是<code>[F, C , B, ojbect]</code> (object最后查找的原则)</li><li>对于<code>G</code>，搜索顺序是<code>[G, E, F, B, C, object]</code></li><li>F中的查询顺序是<code>CB</code> ，而G中的查询顺序是<code>BC</code></li><li>上述的查询顺序违背了<code>单调性原则</code>，这个原则的意思是:</li><li>如果一个类X从父类X1和X2中派生出来，在MRO中，如果X1早于X2，那么在X的任何子类中都应该保持这个次序。</li><li>上述的F的子类G明显违背了这个原则！</li></ul><p>由于上述的<code>BFS</code>算法仅仅针对<code>新式类</code>，对于<code>经典类</code>的<code>DFS</code>算法仍然违背了之前的<code>本地优先级</code>原则</p><h3 id="新式C3算法"><a href="#新式C3算法" class="headerlink" title="新式C3算法"></a>新式C3算法</h3><p>在<code>Python 2.3</code>之后采用了<code>C3算法</code>来处理MRO</p><p>C3算法解决了<code>单调性问题</code>和<code>只能继承无法重写</code>问题，是基于<code>拓扑排序</code>的思想来解决问题的。</p><p>Python官方文档在2.3版本给出了相关的详细讲解<a href="https://www.python.org/download/releases/2.3/mro/">The Python 2.3 Method Resolution Order | Python.org</a></p><p><img src="https://img-blog.csdnimg.cn/img_convert/ac0463a135585152b32cdde9bede5b0b.png" alt="image-20230530143239195"></p><p>对于<code>只能继承无法重写</code>的问题，解决思路：</p><ul><li>造成这个的本直原因是——先查询了子类的父类，而另一个子类的方法重写没有生效，也就是DFS中存在的问题</li><li>把继承关系链看作一张<code>有向无环图</code>，使用<code>拓扑排序</code>的方式，构建一个<code>全序序列</code>，保证子类一定优先于父类被搜索</li></ul><p>对于上图的继承关系链，我们使用<code>拓扑排序</code>的方式来进行一次排序：</p><ul><li>首先找图中<code>入度 == 0</code> 的点，刚开始只有<code>A</code>，选择<code>A</code></li><li>将<code>A</code>的边删除，再找<code>入度 == 0</code> 的点，只有<code>B、C</code></li><li>按照<code>最左原则</code>，选择<code>B</code></li><li>将<code>B</code>的边删除，再找<code>入度 == 0</code> 的点，只有<code>D、C</code></li><li>按照<code>最左原则</code>，选择<code>D</code></li><li>将<code>D</code>的边删除，再找<code>入度 == 0</code> 的点，只有<code>C</code></li><li>选择<code>C</code>，删除<code>C</code>的边</li><li>此时<code>入度 == 0</code>的点有<code>E、F</code></li><li>按照<code>最左原则</code>，选择<code>E</code></li><li>将<code>E</code>的边删除，再找<code>入度 == 0</code> 的点，只有<code>F</code></li><li>选择<code>F</code></li><li>最后选择<code>object</code></li></ul><p>所以最后的排序是<code>[A, B, D, C, E, F, object]</code></p><p>C3算法就是在拓扑排序的基础上构建的，会对图中的每一个节点进行排序计算，一旦发现了逆序的存在就会产生一个<code>TypeError</code></p><p>这也就从根源上禁止创建具有二义性的继承关系了</p><table><thead><tr><th>Graph</th><th>Error</th></tr></thead><tbody><tr><td><img src="https://img-blog.csdnimg.cn/img_convert/4cf04c30aa6a8d886dd4db608b3d1814.png" alt="image-20230530131330330"></td><td>Traceback (most recent call last):<br/>  File “e:&#x2F;myworks&#x2F;vscode_workspace&#x2F;python_workspace&#x2F;python_learning&#x2F;class_learning.py”, line 13, in <module><br/>    class G(E, F):<br/>TypeError: Cannot create a consistent method resolution<br/>order (MRO) for bases B, C</td></tr></tbody></table><p>如果我们从算法角度来考虑C3算法，其实就是<code>把子类的MRO次序基于父类的MRO次序进行merge，并且在每次迭代的过程中，测试是否存在逆序的情况</code></p><p>其中<code>merge</code>方法定义为：</p><ul><li><p>检查第一个序列的头元素，记作 H。</p></li><li><p>若 H 未出现在其它列表的尾部，则将其输出，并将其从所有列表中删除，然后回到步骤1；否则，取出下一个列表的头部记作 H，继续该步骤。(<strong>这个步骤，相当于拓扑排序中的查找并删除入度为0的节点。</strong>)</p></li><li><p>重复上述步骤，直至列表为空或者 不能再找出可以输出的元素。如果是前一种情况，则算法结束；如果是后一种情况，说明无法构建继承关系(存在二义性继承)，Python 会抛出异常。</p></li></ul><p>我们来看不同的继承关系的C3算法的流程：</p><table><thead><tr><th>Graph</th><th>C3 Code</th></tr></thead><tbody><tr><td><img src="https://img-blog.csdnimg.cn/img_convert/ac0463a135585152b32cdde9bede5b0b.png" alt="image-20230530143239195"></td><td>mro(D) &#x3D; [D,O]<br/>mro(E) &#x3D; [E,O]<br/>mro(F) &#x3D; [F,O]<br/>mro(B) &#x3D; [B] + merge(mro(D),mro(E),[D,E])<br/>       &#x3D; [B] + merge([D,O],[E,O],[D,E]) # E符合merge条件<br/>       &#x3D; [B,D] + merge([O],[E,O],[D]) # D符合merge条件<br/>       &#x3D; [B,D,E] + merge([O],[O],[]) # O符合merge条件<br/>       &#x3D; [B,D,E,O]<br/>mro(C) &#x3D; [C] + merge(mro(E),mro(F),[E,F])<br/>       &#x3D; [C] + merge([E,O],[F,O],[E,F]) # E符合merge条件<br/>       &#x3D; [C,E] + merge([O],[F,O],[F]) # F符合merge条件<br/>       &#x3D; [C,E,F] + merge([O],[O],[]) # O符合merge条件<br/>       &#x3D; [C,E,F,O]<br/>mro(A) &#x3D; [A] + merge(mro(B),mro(C),[B,C])<br/>       &#x3D; [A] + merge([B,D,E,O] ,[C,E,F,O] ,[B,C]) # B符合merge条件<br/>       &#x3D; [A,B] + merge([D,E,O] ,[C,E,F,O] ,[C]) # D符合merge条件<br/>       &#x3D; [A,B,D] + merge([E,O] ,[C,E,F,O] ,[C]) # C符合merge条件<br/>       &#x3D; [A,B,D,C] + merge([E,O] ,[E,F,O] ,[]) # E符合merge条件<br/>       &#x3D; [A,B,D,C,E] + merge([O] ,[F,O] ,[]) # F符合merge条件<br/>       &#x3D; [A,B,D,C,E,F] + merge([O] ,[O] ,[]) # O符合merge条件<br/>       &#x3D; [A,B,D,C,E,F,O]</td></tr><tr><td><img src="https://img-blog.csdnimg.cn/img_convert/4cf04c30aa6a8d886dd4db608b3d1814.png" alt="image-20230530131330330"></td><td>mro(B) &#x3D; [B, O]<br/>mro(C) &#x3D; [C, O]<br/>mro(E) &#x3D; [E] + merge(mro(B), mro(C), [B, C])<br/>       &#x3D; [E] + merge([B, O], [C, O], [B, C])<br/>       &#x3D; [E, B] + merge([O], [C, O], [C])<br/>       &#x3D; [E, B, C] + merge([O], [O], [])<br/>       &#x3D; [E, B, C, O]<br/>mro(F) &#x3D; [F] + merge(mro(C), mro(B), [C, B])<br/>       &#x3D; [F] + merge([C, O], [B, O], [C, B])<br/>       &#x3D; [F, C] + merge([O], [B, O], [B])<br/>       &#x3D; [F, C, B] + merge([O], [O], [])<br/>       &#x3D; [F, C, B, O]<br/>mro(G) &#x3D; [G] + merge(mro(E), mro(F), [E, F])<br/>       &#x3D; [G] + merge([E, B, C, O], [F, C, B, O], [E, F])<br/>       &#x3D; [G, E] + merge([B, C, O], [F, C, B, O], [F])<br/>       &#x3D; [G, E, F] + merge([B, C, O], [C, B, O], [])    # 矛盾出现</td></tr></tbody></table><p>所以在Python3中，就是使用C3算法来进行MRO搜索的，确保了二义性的多继承不会出现！</p><h2 id="super的细节"><a href="#super的细节" class="headerlink" title="super的细节"></a>super的细节</h2><p>super只能在<code>新式类</code>中使用！</p><p>在一个class中，可以使用<code>super()</code>来获取到这个类在<code>mro</code>列表中的下一个类</p><p>那你可能就会说了，<code>super</code>肯定是调用父类的属性或者方法！</p><p>但是，<strong>这是错误的!</strong></p><p>举一个例子！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A f1&quot;</span>)</span><br><span class="line">        <span class="built_in">super</span>().f1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;B f1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A, B):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">C().f1()</span><br></pre></td></tr></table></figure><p>上述的代码会打印什么呢？答案是：</p><ul><li><p>A f1</p></li><li><p>B f1</p></li></ul><p>明明A和B没有继承关系，为什么A中的<code>super().f1()</code>会执行B中的f1呢？</p><p>其实是因为super看的是最初对象的<code>mro</code>列表</p><p>C的mro是，<code>[&lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;object&#39;&gt;]</code></p><p>所以在A中的<code>super()</code>获取到的是<code>mro</code>列表中<code>&lt;class &#39;__main__.A&#39;&gt;</code>的下一个，也就是<code> &lt;class &#39;__main__.B&#39;&gt;</code></p><h2 id="Duck-Typing"><a href="#Duck-Typing" class="headerlink" title="Duck Typing"></a>Duck Typing</h2><p>duck typing就是我们常说的<code>鸭子类型</code></p><p>在Python中，如果某个类实现了一些特定的方法，但是没有显式继承某个类，这个类也可以是某些类的子类！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyIter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(MyIter, Iterable))<span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>虽然这个<code>MyIter</code>没有明确写上继承自<code>Iterable</code>，但是通过<code>issubclass</code>的信息可以知道，<code>MyIter</code>就是<code>Iterable</code>的一个子类</p><p>这就是<code>鸭子类型</code>，如果一个东西，它长得像鸭子，叫声像鸭子，走路像鸭子，那么它就是鸭子！</p><p>而鸭子类型的实现，可以通过<code>__subclasshook__</code>这个魔术方法来实现！</p><p>我们来看看<code>Iterable</code>的源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Iterable</span>(metaclass=ABCMeta):</span><br><span class="line"></span><br><span class="line">    __slots__ = ()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">False</span>:</span><br><span class="line">            <span class="keyword">yield</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__subclasshook__</span>(<span class="params">cls, C</span>):</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> Iterable:</span><br><span class="line">            <span class="keyword">return</span> _check_methods(C, <span class="string">&quot;__iter__&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br></pre></td></tr></table></figure><ul><li>Iterable定义自己的<code>元类</code>是<code>ABCMeta</code>，有关元类的知识点之后再讨论。</li><li>Iterable定义了一个<code>abstractmethod</code>，这个抽象方法装饰器的作用就是，如果一个类显式继承<code>Iterable</code>，那么这个类一定要有一个<code>__iter__</code>的方法，否则会报错</li><li>Iterable定义了一个<code>classmethod</code>叫作<code>__subclasshook__</code>，这个方法在调用<code>issubclass()</code>函数的时候会被调用，检测C这个是否含有<code>__iter__</code>这方法，如果有，就返回True，那么在调用<code>issubclass</code>和<code>isinstance</code>的时候就会返回True，证明是子类</li></ul><p>说到了这里，其实Python中很多类型都实现了<code>__subclasshook__</code>这个方法，例如上面提到的<code>可迭代对象Iterable</code>，还有<code>迭代器Iterator</code>，还有<code>生成器Generator</code>，都是通过判断某个类中是否存在某些函数来判断是否是子类。</p><p>其实可以自己编写一个demo：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyBaseClass</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__subclasshook__</span>(<span class="params">cls, subclass</span>):</span><br><span class="line">        <span class="built_in">print</span>(cls)</span><br><span class="line">        <span class="built_in">print</span>(subclass)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasattr</span>(subclass, <span class="string">&#x27;my_method&#x27;</span>) <span class="keyword">and</span> <span class="built_in">callable</span>(subclass.my_method)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySubClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">my_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(MySubClass, MyBaseClass)) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(MySubClass(), MyBaseClass))<span class="comment"># True</span></span><br></pre></td></tr></table></figure><h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>如果不想使用<code>Duck Typing</code>的方式来实现多态，可以使用<code>抽象基类</code>的方式来规范父子类标准。</p><p>从一个小demo看起：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyBaseClass</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">need_this_func</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__subclasshook__</span>(<span class="params">cls, subclass</span>):</span><br><span class="line">        <span class="built_in">print</span>(cls)</span><br><span class="line">        <span class="built_in">print</span>(subclass)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasattr</span>(subclass, <span class="string">&#x27;my_method&#x27;</span>) <span class="keyword">and</span> <span class="built_in">callable</span>(subclass.my_method)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySubClass</span>(<span class="title class_ inherited__">MyBaseClass</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">my_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">        </span><br><span class="line">MySubClass()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;e:/myworks/vscode_workspace/python_workspace/python_learning/class_learning.py&quot;, line 88, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    MySubClass()</span></span><br><span class="line"><span class="string">TypeError: Can&#x27;t instantiate abstract class MySubClass with abstract methods need_this_func</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>上述代码实现了一个抽象基类<code>MyBaseClass</code>，因为这个类继承了<code>abc.ABC</code>，而<code>abc.ABC</code>的元类是<code>abc.ABCMeta</code>，这个元类规范了<code>使用了abstractmethod修饰的函数一定要在子类中实现，否则报错</code></p><p>所以在我们自己写的<code>MySubClass</code>中，<code>显式继承</code>了<code>MyBaseClass</code>，如果没有实现<code>need_this_func</code>，那么就会报错！</p><p>使用<code>抽象基类</code>的方式可以更好的规范我们的父子类代码！</p><h2 id="类方法与静态方法"><a href="#类方法与静态方法" class="headerlink" title="类方法与静态方法"></a>类方法与静态方法</h2><p>类方法在class中可以使用装饰器<code>@classmethod</code>来修饰，第一个参数是<code>cls</code>，表示当前这个类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>:</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">instance</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hasattr</span>(cls, <span class="string">&quot;_obj&quot;</span>):</span><br><span class="line">            <span class="keyword">return</span> cls._obj</span><br><span class="line">        cls._obj = X()</span><br><span class="line">        <span class="keyword">return</span> cls._obj</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(X.instance())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(X))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;__main__.X object at 0x000001EB271CFD30&gt;</span></span><br><span class="line"><span class="string">[&#x27;__class__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dict__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__le__&#x27;, &#x27;__lt__&#x27;, &#x27;__module__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;__weakref__&#x27;, &#x27;_obj&#x27;, &#x27;instance&#x27;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>这里就用类方法类生成了一个实例，同时这也是<code>单例模式</code>的一种写法</p><p>静态方法可以看作<code>类方法</code>少了<code>cls</code>这个参数，就相当于是绑定到一个类上的一个方法，不需要生成实例就可以调用的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Util</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">date</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;20230531&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(Util.date())<span class="comment"># &quot;20230531&quot;</span></span><br></pre></td></tr></table></figure><h2 id="metaclass"><a href="#metaclass" class="headerlink" title="metaclass"></a>metaclass</h2><p><code>metaclass</code>翻译成中文，就是<code>元类</code></p><p>我们都知道，在Python中，万物皆<code>对象</code>，但是，思考一个问题——<strong>对象是由类创建的，那么类是由什么创建的呢？</strong></p><p>答案是，<code>类是由其元类创建的</code>，同时<code>元类也是一种类</code></p><h3 id="type元类"><a href="#type元类" class="headerlink" title="type元类"></a>type元类</h3><p>在Python的基础类型中，所有<code>基础类</code>的<code>元类</code>是<code>type</code></p><p>你可能会疑惑了，<code>type不是用来查看某个对象的类的吗？</code></p><p>但是<code>type</code>的用法远远不止这一条！</p><p>我们先来证明一下<code>基本类型都是由元类构建的</code>，看如下的代码输出！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">str</span>(<span class="number">1</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">str</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">int</span>(<span class="string">&quot;1&quot;</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">int</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">list</span>(<span class="string">&quot;123&quot;</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">list</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">tuple</span>(<span class="string">&quot;123&quot;</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">tuple</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>发现了没有：</p><ul><li>所有由基本类型构建的对象执行<code>type()</code>后，都指向这个类</li><li>基本类型的<code>type()</code>执行后，返回的都是<code>&lt;class &#39;type&#39;&gt;</code></li><li>这个<code>&lt;class &#39;type&#39;&gt;</code>其实就是<code>metaclass</code>，也就是<code>元类</code></li></ul><p>来解释一下相关概念：</p><ul><li>元类：<code>实例化产生类的类</code></li><li>元类 –&gt; 元类.实例化() –&gt; 类 –&gt; 类.实例化() –&gt; 对象</li></ul><p>既然我们知道了基本的数据类型都是由<code>type</code>这个类构建而来的，那么我们可以不使用<code>class</code>这种关键字创建出一个<code>类</code>吗？</p><p>答案是——<strong>肯定可以！</strong></p><p>我们就使用最基本的metaclass——<code>type</code>，来实现无<code>class</code>关键字构造一个<code>类</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class_name = <span class="string">&quot;Wood&quot;</span>     <span class="comment"># 类名</span></span><br><span class="line">class_bases = (<span class="built_in">object</span>, )<span class="comment"># 基类</span></span><br><span class="line">class_dic = &#123;&#125;</span><br><span class="line">class_body = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">def __init__(self):</span></span><br><span class="line"><span class="string">    pass</span></span><br><span class="line"><span class="string">def info(self):</span></span><br><span class="line"><span class="string">    print(&quot;test info&quot;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">exec</span>(class_body, &#123;&#125;, class_dic) <span class="comment"># 使用exec将class_body中的内容装入class_dic中</span></span><br><span class="line">Wood = <span class="built_in">type</span>(class_name, class_bases, class_dic)</span><br><span class="line">obj = Wood()</span><br><span class="line">obj.info()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(obj))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(obj))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">test info</span></span><br><span class="line"><span class="string">[&#x27;__class__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dict__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__le__&#x27;, &#x27;__lt__&#x27;, &#x27;__module__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;__weakref__&#x27;, &#x27;info&#x27;]</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.Wood&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>上述代码的输出结果已经告诉我们了，这个<code>Wood</code>类已经被创建了，并且是使用<code>type</code>的方式构建的！</p><p>我们可以根据上述的代码思考一些问题：</p><ul><li>class关键字到底做了什么来构建了一个class？</li><li>元类充当了什么样的一个角色？</li></ul><p>其实第一个问题思考一下就可以得出简单的答案：</p><ul><li>获取类名</li><li>获取基类（父类）</li><li>获取名称空间</li><li>调用元类构建这个类</li></ul><p>第二个问题在刚开始就说了：</p><ul><li>元类的实例化对象是一个<code>类</code></li></ul><h3 id="自定义元类"><a href="#自定义元类" class="headerlink" title="自定义元类"></a>自定义元类</h3><p>先看一个demo，继承了type的元类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyMetaclass</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(args)</span><br><span class="line">        <span class="built_in">print</span>(kwargs)</span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line">        <span class="built_in">print</span>(self.mro())</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">dir</span>(self))</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>(metaclass=MyMetaclass):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">X()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">(&#x27;X&#x27;, (), &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;__qualname__&#x27;: &#x27;X&#x27;, &#x27;func1&#x27;: &lt;function X.func1 at 0x000001D969F9C1F0&gt;&#125;)</span></span><br><span class="line"><span class="string">&#123;&#125;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.X&#x27;&gt;</span></span><br><span class="line"><span class="string">[&lt;class &#x27;__main__.X&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span></span><br><span class="line"><span class="string">[&#x27;__class__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dict__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__le__&#x27;, &#x27;__lt__&#x27;, &#x27;__module__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;__weakref__&#x27;, &#x27;func1&#x27;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>可以看到输出，<code>args</code>中有三个参数：</p><ol><li>类名</li><li>基类（父类）</li><li>命名空间</li></ol><p>所以可以看到，在<code>元类</code>的<code>__init__</code>参数中，传入了需要被构造的类的必要属性</p><p>那么我们可以在<code>元类</code>中执行什么样的操作呢？同时又有如下几个疑点：</p><ul><li>如果仅仅是在<code>__init__</code>中注入一些属性，那么如何解释传入的参数中不存在<code>object</code>，但是<code>self.mro()</code>中又有<code>object</code>了？</li><li>Python3中都是新生类，如何保证class申明后不显式继承<code>object</code>也会自动继承<code>object</code>？</li><li>有什么方法是在<code>__init__</code>之前就执行的？</li></ul><p>我们一个一个来解答，首先来了解一个类的构建过程。</p><h3 id="new"><a href="#new" class="headerlink" title="__new__"></a>__new__</h3><p>我们一般会把一个<code>class</code>的<code>__init__</code>函数当作构造函数。</p><p>但是，其实真正创建一个类的函数是<code>__new__</code></p><p>我们来看一个例子，证明<code>__new__</code>在<code>__init__</code>之前执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyMetaclass</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">50</span>)</span><br><span class="line">        <span class="built_in">print</span>(args)</span><br><span class="line">        <span class="built_in">print</span>(kwargs)</span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line">        <span class="built_in">print</span>(self.mro())</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">dir</span>(self))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(cls)</span><br><span class="line">        <span class="built_in">print</span>(args)</span><br><span class="line">        <span class="built_in">print</span>(kwargs)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls, *args, **kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>(metaclass=MyMetaclass):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">x = X()</span><br></pre></td></tr></table></figure><p>我们直到<code>metaclass</code>构建一个类的流程，由<code>metaclass</code>创造一个<code>类对象</code>，上述代码中这个<code>类对象</code>就是<code>X</code>，再由<code>X</code>创造一个<code>类对象</code>，这个就是上述代码中的<code>x</code></p><p>那么上述代码的输出是什么呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;class <span class="string">&#x27;__main__.MyMetaclass&#x27;</span>&gt;</span><br><span class="line">(<span class="string">&#x27;X&#x27;</span>, (), &#123;<span class="string">&#x27;__module__&#x27;</span>: <span class="string">&#x27;__main__&#x27;</span>, <span class="string">&#x27;__qualname__&#x27;</span>: <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;func1&#x27;</span>: &lt;<span class="keyword">function</span> X.func1 at 0x0000013C3A89C280&gt;&#125;)</span><br><span class="line">&#123;&#125;</span><br><span class="line">--------------------------------------------------</span><br><span class="line">(<span class="string">&#x27;X&#x27;</span>, (), &#123;<span class="string">&#x27;__module__&#x27;</span>: <span class="string">&#x27;__main__&#x27;</span>, <span class="string">&#x27;__qualname__&#x27;</span>: <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;func1&#x27;</span>: &lt;<span class="keyword">function</span> X.func1 at 0x0000013C3A89C280&gt;&#125;)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&lt;class <span class="string">&#x27;__main__.X&#x27;</span>&gt;</span><br><span class="line">[&lt;class <span class="string">&#x27;__main__.X&#x27;</span>&gt;, &lt;class <span class="string">&#x27;object&#x27;</span>&gt;]</span><br><span class="line">[<span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;__weakref__&#x27;</span>, <span class="string">&#x27;func1&#x27;</span>]</span><br></pre></td></tr></table></figure><p>可以看到，<code>__new__</code>的输出早于<code>__init__</code>，所以我们的结论被证实了。</p><ul><li>每个<code>class</code>，都是由<code>__new__</code>构造出来的</li><li><code>__new__</code>早于<code>__init__</code></li></ul><p>那么在哪个地方会让<code>metaclass</code>去调用<code>__new__</code>再去调用<code>__init__</code>，最终再去构造一个基本类呢？</p><ul><li>有一个魔术方法叫作<code>__call__</code>，就是一个<code>类的对象</code>在被调用的时候会执行的</li></ul><h3 id="call"><a href="#call" class="headerlink" title="__call__"></a>__call__</h3><p>如果在一个类中，指定了<code>__call__</code>方法，那么这个类的<code>实例化对象</code>也可以加上<code>()</code>被调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.name = name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwds</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name)</span><br><span class="line"></span><br><span class="line">obj = TestClass(<span class="string">&quot;woodwhale&quot;</span>)</span><br><span class="line">obj()<span class="comment"># woodwhale</span></span><br></pre></td></tr></table></figure><p>上述代码中实例化的对象<code>obj</code>，如果被当作函数执行，就会触发<code>__call__</code>函数，从而执行<code>print(self.name)</code>这条语句</p><ul><li><code>__call__</code>函数是可以有返回值的，当作一个函数就好理解了</li><li><code>__call__</code>函数还可以有参数，这点也和函数一样</li></ul><p>还记得如何使用<code>type</code>来构造一个<code>class</code>吗</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class_name = <span class="string">&quot;TestClass&quot;</span></span><br><span class="line">class_bases = (<span class="built_in">object</span>, )</span><br><span class="line">class_dic = &#123;&#125;</span><br><span class="line">class_body = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">def __init__(self):</span></span><br><span class="line"><span class="string">    pass</span></span><br><span class="line"><span class="string">def info(self):</span></span><br><span class="line"><span class="string">    print(&quot;test info&quot;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">exec</span>(class_body, &#123;&#125;, class_dic) </span><br><span class="line">TestClass = <span class="built_in">type</span>(class_name, class_bases, class_dic)</span><br></pre></td></tr></table></figure><ul><li>既然<code>type</code>是一个类，那么在调用<code>type()</code>的时候，其实触发的就是<code>type</code>这个类的<code>__call__</code>方法</li><li>也就是说，在执行<code>type(class_name, class_bases, class_dic)</code>的时候，其实是在<code>__call__</code>函数中返回了一个<code>类对象</code></li></ul><p>让我们思考一个问题，一个最简单的<code>类</code>，它的<code>__init__</code>函数，为什么一定会被调用？</p><ul><li>其实就是因为最基本的类的元类是<code>type</code>，而在<code>type</code>的<code>__call__</code>函数中，会调用这个最基本类的<code>__new__</code>和<code>__init__</code></li></ul><p>那么如果我们编写一个<code>MyType</code>继承自<code>type</code>，同时在这个<code>MyType</code>的<code>__call__</code>中动手脚，是不是可以控制一个类的产生？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyMetaclass</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwds</span>):</span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__call__&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;woodwhale&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>(metaclass=MyMetaclass):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(X())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;class &#x27;__main__.X&#x27;&gt;</span></span><br><span class="line"><span class="string">__call__</span></span><br><span class="line"><span class="string">woodwhale</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>可以看到，这里<code>X()</code>的返回值是<code>woodwhale</code>，调用链如下：</p><ol><li><code>X()</code>的第一步会去先实例化一个<code>MyMetaclass</code></li><li><code>MyMetaclass</code>的实例化对象是<code>X</code></li><li>而<code>X()</code>其实就是<code>MyMetaclass</code>实例化对象被调用了，所以会触发<code>MyMetaclass</code>的<code>__call__</code>函数</li><li>在<code>MyMetaclass</code>的<code>__call__</code>中，返回值是<code>woodwhale</code></li><li>所以最后<code>print(X())</code>的结果是<code>woodwhale</code></li></ol><p>这样的调用链就很清晰了！</p><p>那么我们可以在<code>__call__</code>中，实例化一个<code>X</code>的对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyMetaclass</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__call__&quot;</span>)</span><br><span class="line">        x_obj = self.__new__(self)</span><br><span class="line">        self.__init__(self, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> x_obj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>(metaclass=MyMetaclass):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="comment"># return object.__new__(cls)</span></span><br><span class="line">        obj = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        <span class="comment"># 随意操作！</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__&quot;</span>)</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">x = X(<span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(x.name)</span><br></pre></td></tr></table></figure><p>所以，如果我们想给一些类做定制化处理，可以在<code>metaclass</code>的<code>__call__</code>函数中处理</p><h2 id="属性查找"><a href="#属性查找" class="headerlink" title="属性查找"></a>属性查找</h2><p>在通常的认知中，类与对象的属性查找的链子是：</p><ul><li>对象 –&gt; 类 –&gt; 父类 –&gt; object</li><li>找不到就报错</li></ul><p>但是，在了解了<code>metaclass</code>这样的存在之后，其实查找链就有两种情况：</p><ol><li>对于对象</li><li>对于类</li></ol><p>对于对象的查找顺序，其实还是我们认知中的链子：</p><ul><li>对象 –&gt; 类 –&gt; 父类 –&gt; object</li><li>找不到就报错</li></ul><p>但是，对于类，就不同了，多了一个查找元类的链子：</p><ul><li>对象 –&gt; 类 –&gt; 父类 –&gt; object –&gt; 自定义的metaclass –&gt; type</li><li>找不到就报错</li></ul><h2 id="After-All"><a href="#After-All" class="headerlink" title="After All"></a>After All</h2><p>上述内容仅仅针对<code>Python</code>代码层面的类，并没有分析<code>CPython</code>这种更深层次的源码分析，未来有时间一定看源码！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Talk】春招实习总结</title>
      <link href="/2023/05/26/spring-find-job/"/>
      <url>/2023/05/26/spring-find-job/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="7e92e956046d692c32f2cc03fadebc09a24355cef1cda9db238d5fd36cfe27e0">8c83c1fd70b2001f095a68c8e758fb29a7c127bab7fdd108d35a9a25fabd6baba79a48c89305987f740fc96cb45830bcc7bff86bea22d7fbfde951f267073f6cee2ffcaac8fef14e4c4a933c848b081708abc0490b47cf5b483867a2e0b39a0e116a0ecc6f88a968d6ac59396977e7023555f0afdfb7107d80ed388a073c3e92e120dadf3d58a61683b7c56e7cb418c8a2e144177d741288abac82295ebcb4b9e220a494210b94278671a43c8e1ca4fd5130ce240443458d75e6befb05c5dfb1c764ed2de470a9e0c085669887a13406044b2ba22c73eb26984bf87c6a4ee8e7f538eea2d24aca301295c5f9fead835a635b673295b8df5af2adc8bd83d621350815e500cca0b97c970f38c7f434d1bf340a712bf52a5c31712b97eb678c780b9c01cf650397298c39c0e933628bfe613f42d01858c67e1bbaf0b846f81cac58a4d7c989047d6f67a83d3c9f041134a4fa8d25070d1bbfa17bd25082b14c1dbb584fc6f9641fdc74a0aae96c53be58779af2b3a10d21530b3360b3b7dcfbe9c6a11dc4ec45337751b424c136fea246a55088d1c9af5c015aa3973b737a6876f17da611d4683b1b5505d8e20c533593d0a00de67f2b0dfa86c1639b458f68f9685f3ae9ee11d18f04678fbd41a07d5a00c76ad144b6027a97beec4d312c6c8c5d179723d242af2ab9d381a9edfccbf6afd4a85486a8b10ce04b8d47e8081712464312ac82d985f7c8a6034f760e111ff0100991d7f1f600a46981ada70d5bb2be75d2682029d5178738794a1c1de60f41798bdef8fb56485dcdceed175c3dae061c35b0b6a88cf8198178d675e2de66fda5d268e5d32c497fce2a1180113c75774605e19af75e09a74ebbb60fd0bb6042557bbd67bf0c8eacb2b8c6fe569358e1e60a2a717b95157b94d64b9715518c4c40945139ebc1146109dfc75fed810e85a65b7af5b35c137caaa41f2a056637fcf8e4f51647673320c42af6adab76388cb2133ff001e4bf533f302c3fc601b50006d9f775b7ac0b7c9996455d210ae9ae624305760964ee9aa3b3227c699db05586c2a4f828e6d27c7c494bfc77eb48bc2c648688c0e0410dae9c2d7730e1c415976c1e9d0f4cd13f8a7ba09e0bfd9874f4956a42716cfbeea39b12c08029c8c93e8a4c7af4fe3fa41e0ef3fb5a199ef64263cba3ce9b060590da932c243d29d2b29c1c2467b7324e443535b0546010dd865cd2562bcf9e050b3cf68b43ee1d17922dcdd93789c5e98943f75e0f1cbef226db5ff88324ecebbc6654a8be177569cb60c0bb92c741c729d1459f39b9d735953c878f5c2416de5245d9823672bd586a605cb4caa378192051d9076776f96e8d906cc5f1b9452ffcddd5205c55915f18df1495adb4089207472d2ab858a2c9b6876192531e6d90f832d0ffc70983958d63a9ae80807b74c86b71454595e8f91b4a9a3b3f149ec37a71fc0461f292d7692d18e9ef7b90f548bf03686db57b88bdbf0d15a7fc6f4d9b749442b6ebd8177e3debceb4fbe790df90bf29ca583db034d72bad9aef918cf4edaca64fcfca490472d63d1a39c768ac995bbe582ecbff0d5d68530f2798184597afdc3ccb268a2f30fa05b5128554b5277b379957c0eeddd83f1f821c2ad69e4697a8389aa03bf3e8adbfae14d72b6268bb82bfc6e41156c8b0ff566c0635a98b02dbe95e99002209d00e1d4e9bcfaa4bf7c34b35225f7698d34aa5143041ededad52cae43d2a76db7f7719ec4971a0eb0e5138aae072b5c6335a5a74a6c2054dd533d1c00e512bc5f7a0d8ab45cac07df2fac1430eb346c5865ad48232a34214065fad995243275d6f5849460c8eefd13df0c2b633510baf6688f02838069cc26c104fd79c5d32edaf4d97c1a4322811d28a56608f146165fda04ef637bdbee38d0a738428a82579df869f8d8b3caef572424a0ca937ff82f2e5ae5b369366941330d6f450085e6b6791f66ba4c2f83c66bb76402a3a22acb2c5a3df10548cac2a6c9ba4e9c562789249f23b8912f0f03debcb1d471524cb1f68882de55734b0c4191c09723f63a14d505197d6aefc8684eed630e5cfa756dc08025936f74f3e247d34ca0cc8d0abb66e3ce59b38bb17e2ae55cc18a7b424405393eabb16136fe1e32a33d1ad5c37901c64c5d0e00fd62be108e5e5d14a5e9b780a78f80fa6606ded65e2bcef0bec431ccf5dcec9857ccb75f1904e654461a2ee06471b021755dfb54ef5c2a9be647f37ba0ccb859d11b08f43bd3c124a9a7d6f213e22448b8c7242d5c6211b4f1c4661a1b06d76fb58b8fcf51058e1afd827c8cf306ed586c8454cf9bd44396d572b9869ba8106bd58cbeb1075e3985d311f54f6610f007fd4523dafc1322f29bab68e07b041fac2884ccccb68a9b62ccb434f8a27305dcd17251b995f0e4acf639fc2e45bfd3674f82d818a414c5f3cb4787ca92d626127f896e109b46e52d1c92ad9ebdacb2155e40704abee6e9211e2d17ba89a960dd14f9b63cd3a120f212072bc9de6d07ae45ed89ff4c426f7aeecc5d0d70cd4f7052cacaba8e173602d7097b77fa556d36079d077174efa1225bd35513d9243303945b8bf909cb75a8f6103364d02e5f4f5e4aff7db33373df88c6bf9934272da1300b3762fc8de53a3641fb1d4ccc8a574c7a2eb9e1b5ba60003af3e19ec4f69f2097c9c5e7c8da5f9879fa6d38e245c3144af783d3e1d34e84ce56d4ddca20063d0c45ce7532d88cfef1370e73940dc34f82aec41b9e595f0fcd040e565a495a33520cd125ea4134af14014dee820a90a692ef767ef8c89777ff9c9dc28fbd518795efa842b43830163993fd38658ff822b939811d075a3384e32bd328d383d5a05d65aa13aeb749d27465164b93070f1820ed4e3d491aec96ba4234fc1fe0b58eae08d82b4b6f75284e6c34ecdecc22ac3ca1afdeb3175618855fbac1993b5202d0d68a932a81f5e2e7c01edefac3ad15b21549e659e9b172dbd22bcac27cb0e14512f63d510e60c5453b4f6ccc067ced5cf46725d6a4566bbc1e71be8a8152565acdfa51c1e8dcf99505a0a15e907ce7a4b160532ac7a02dbdd63167fd2eefad25c368450865bf5b4e6146bc1dcf30d618acb489e7262d45d48517f712117fc5d39a02c20c251e0b100cab7fb3f4a79b35bd4b8d9595e8b648f1bd95ed105f3f7304a9ab401b02e5a92ef07ce2c816b40547a6612466b2942137fc54e4a93c6e33e2cacba13dbc9658d628841146ab74a059476d05cab9c28bd0b42b0f9c6421cb38f2ec89eadc35d1d1b68a4f376b533fe63895489ea7d50031c8856a62a289c182692357047f0a7f98670eaa1fdcbfa07fdb5386fb7e409c29c202ae8dfc7f58323b88d20c646f09e8284b65ce33b8927958cb5463050cfef28f730d7a9578b2de4247a09b583635f9c6ccaa94152271786ad1b0f13531ee42f0bbe427794642bd4649f8e39e3b92c0ba190e61dd525e9c4cf3f0b82e5ac6047500df67f38cd2ae880f6b81605845ca5b90a55d59ec80b2186b81be36032864c1bb70139d00a4b1e5a6c2e5776bda2f861630875236860919aeda788aacb6c3d9a88d36cf557c97e0c284bd22c39232bfa5e56e6d234ced170471e3a2c384cc440a2ecffb5a4f53b2be889e9e2abc3b138e7d93e7be6f2403e59d0869ea8f504c0c9bfa83a3c01626412f28ac575e092ff98991232d47f6d3f6026d25eb227e6a34248c19346880a33740c1439d929fa9b4b8b0da1f6d060adea246196696873fd3f3487187e2996582c094aa469a32a3ec434779c4c767c5a61cfccf7f7155448198ebb319fdf169512fa9c601fa054c1a91228a41bf7755cacd162f5cbf6bf7498d70c870cc0a347d7557e018a933ab4345bc033d1a75a08715a984b310162b7c1ccc07257355fe6de2a853cf1dce66254002510f35b4b158fc332bf137f8aa53ee283472dbc7da70389b6a1dd2f5e200fbc5970ac7048f4c4601bc7fb31d264f28268d2c8b515a97450787b5c4ab1c2e2c3de307d4f0304d3a49e606130dbb64068341c06edfe178aa9f8d8c87deca7641b187cd04edd897e53420947ee1f75a382f3d19a4d99c6ee8dc3ab40bb1181a634861a3f5872fead5905ffed227b8328f5a78c62c1f20fcb34e933d66a36819597e354a6c3c44dfad031cac2694ad2d71a7cf196553afebdc9f188de849794ee665a993a8c860eb22a0769f42add611dca5f6b968aa6f4a57ee2d9e38aa11c53c0ae710f7bffd61f829d02702d1a44644a330c390ce338bdccf45b8457475eee44499daac1ef21bd1f2b10a0358e34b473b09032b814124e5d06333c75c02ee72baff1659d50543ead385abfb26ad03a26c679e27c585488fcb8aeb9ca531aca7821ddc74077029d4ad47d08ba663e1259c903babbb946f699fa74480a4152983f9daa78abdcb161e4cbc07da008555253eef3e2138432b08cbe5e97a6933bf029c2d66d1868d77cd47f7a140f9e51eb3622f21499197cc666a57463fd2a6457304c532abe962fca0ff099000baea013c51f07b5c27cf0814dc67f7f03efa73c8d9eead0b33d1dc6c871a4bef342e93d3790ac9816a0414ee1e769d33fc42b9e75f20e08a81efc959234a794ba13343e47d7f7c2ae7d43b2b2fa30cb01c98b9a521d0ce2022fc76f0dec891e0a9c39f936377ec626a4485c56f821482d30e0a710f7259a7a5ccb29157cfbe32700fd17463be76e540de907e1a2b7d6e17b83b6b4ecd6417a06eebddcefd6a3b429ed41a80ce75f77c362ef7f8ed94fc4a281174f95db594f5d62ba97b50e4eaa46a599fe57dee23c79199d608bd5c597eea9f44159dcab6c811f7a841b9a3789c189bb64b50c8816f2a500560f913e7c9bad45ff8ce16f5b8332c593b6afe34cd764ef598ad1b7f6345d7781db71bc68a2c6011380af91b75a99ee04b35e10a0822e0c9cb0cbf45051f16cce9f79eea0e5ada5331212e247e3d6caebb79a3ec1d85eed04eb92971b32ffc98075b6cb151a81f4ec611d521661b03d388d374497a9ec61a8a97c153e298bea9379e2e51a9aa72d816d91515bcb4eb86e923b4e7aae9e70a79ff90671f9bb18c40a5d8491957304f556487afaa0131e71d813c876d5d56524d23d124ec6786a20b7509dac5073a4b797922c4f81ee296da773cd5ed4f482849706437ff0a8fb917ca9fa1ab607d87ff4999db1abeb1fdd1ccf29e48d9760e62bb501e60e66c7815986b5a25b2ff330dd156344975b7d94fbe3ca3ecef5a4dd0ba45542f5cc3cef33ddf71e161280ffaa6d11faff41d4b9f0176e1bb8bccdb1d5ca3205e3a7d34bbe0bade4abe4a8a2fd42b008b2d14d821de113853e366259ebac989874941a11c6dc454d2c133d94969c85071d1774ec7553e14f2c9883bddd7f95c5ecb7f945d54d54b0babd2c1bdfb51128bb4fa4c38c9939d08bbc577e5b42303dddeadbca5376930334a6e2e1e48ec1055cdc906686b089bcbea711a02215f853e7bbd5b9b2616dce8d479d150b4b1ac42672aa878b5130e471816f5e33bbff4bf8491db28f49dba60e1e72f948ba18fcbde85c0d88a953ef9b864cec765e1688f22fd4fd226956940ea6eca09755cc47fc6db175b0610078b02cabf1729ccfda98c66ece1aa00bd310b353ba1d467378e4b423ae5b435f0f02809854540a56bafc4774d81a57d1dbaedf3b72f82b30a8b4bf079a70a9ceeb9faf63523e1eef871ae81107fd12db3975ba7d74566d9f9c182a1ea337405ae4fe0eaa80092f3e760c5e28aefe5fc6361725909f577769c05e67d4835503d0a2d2d6f26ef24e0fa8e6eed95e6813b1091390737844f09dec8b8f32c832da933fefbf432bf5f23788ac2f51a8997924b4a24fc0658096bbc721b467b4c1a918efc2c409790ff8c6feead38820a884484392fdb4666ba15319012d1453b978aa10302fb85b5cc8810917dfe071bf5aa06eb6d8d6011fac766b022cbd37b073811a53842c070423a8171bc573fb63357fb80ff44620935590192f48e454e24068ad1da02999b4fb1f43754a879bbe184b33b6222d1773cb516121d1b02b3377bfbc37c03c2e0cd7c87dd2f5d9d04cf52c05c0051606390497da8d038f13c77ca74693202a25d56ece3a40bd3f634097cfbc84b61b454be78e1b3a0543c2900effd0bef5e5508dd1fd9ab1bd54cadf2774002a2cb0259c3ec563c82739038dbcc3f14f261db7239138aa42c2703ddc1d61b228cab3c62b226c82b02665267d41989a4360c340e9c96796ab596fa2b9c6378747b3fb3af1df474d195835f74a0dcc54bf5d26fc93b551137bda8a07f9d7dbb220b18ceac0b4d32522a49a6aaf5ebf77ea9f7d768c468bee68303c9e0a23703c8bb3305af5756b705808098fb024e8327e51b3c0f05faa862f47845e34708406d24d8b0cacc84471b3b987835f5b930efdc80830ab512d78eea8c0fe196c8e1bd9a3988c6fbab167f43a087506670183a2196db4565bfc4921b40a08cd36b7c255b45436ff287a058cd6fbe6a97a0513e11fb8e46373527c16c96dabc09f8cff5f77ce3deb2b8a2703a95cca027060dd33e359a38445fae7b2121d8af07196006318c996b23cf410371ce7c61f96841885dbd19a620106dbaeac5a7fca6a457b312628a87e0545b0dc69c2f710098885f2f07e8f89fe1809bf240ca73b38d500785fbebc2cbd0dd7eb49b2c5260169f8a8c61594760c62deb076ed95f49dfabc397448902e3d53ec5a2e6eea261a4993f13f82866c96e0bb4ee282b6c09a93f778f8338068b32713378e09533649ee695375defcbeed25b7a35a9ff584ca5cad8209c14e61f558b7ce8b3dffe3c4c9480871efce93665bc44489fb2e602b22e3c3aa71b8a297a6df48960a08e1037fdd050c4ecca364b37c300906246a9c6070569766eed5e6593c72a727f8f119395297ecc82321725e541c011cea84ccc51cc384ef607f3de501d1e8260193a138daf8a0ad01d8899cb9ff4b7ffd4fe1d803601c876d1978cacd276d7a80c019476b1de62be485083b2045fe59bb5f7ce74c7d4749265e326bc3828b268d947acb08ff6d70e282c3f4bb6f15fe83fe7e89be092f53ae46b92d52dbf019a544b5aefeb2ffa988ef190e2dda337561acf7ff474899cf4a5c585321902b0d67c1ad3d24eb2fef71e3ef47d76948af54279d9895f083abeb91e8e1e18cda1f7c473761af9a55d99ce3b5cca544d1978dc5492f803ad6bd484e12ff8804407c6600072db24826628c4e1351dad04cba33aa8fc25a45147b2f32b55ee92e0c3126993c88617f49c75e887f16f603c4def02eeb98c55d84f3d59a4bd8211ec48bd490a9ac18525cfafec2213643983edd8b9b98c406edb7c606b1b14ecd51012981909a4e7b09c3f492a90b35df4e033d80c29c70464c4ab0b94d1b5f1c44414517abe88eeabdad685ca2e4333313a971a7fd4f5c20f475617551f0a51dc4f5e5d67655ed0b4e7f5e7a406a027828914796eef7550c0dd3577d5421178453b7b54dc1fdd37df4f02830cba9eb7fa4ba3066211adcb9dc111eea50827f3bb09ce3e08cbc22a332df50b6f3c22332abc3319102b0449487c837347f199321b478597e408f496cf317d7682fb595fea0faffc3e350f7bdeb489ebc2507c5c61b8ecabb5b5c0b9b27807f349f53744be412328c3063e2567ed245973a60e409dcfa72d5ab97563efbd9b1f99409d0027d7a7a01a96602eb8360ba4dd0d718383657c5b1a6c47789bcbab27923952541a3dab82bf94685b316c3de77cbabcde6dc4370fe947ef37a58d5bdc4c5d187df0323abb9c78c8e5e134d61ca94355b2dc8c9221e4cf9977f9385ffef709a37892346fcee612f7611881b4470726b8d2525a02e645345facc1810955582a3e28ebd9e57a84f7fb171610df21ecf2674b2b58a713629fc2b19a0de7a2ac981e62af34eeabbf2eeb28371692a3ff28cae56695767447d2c4a675beecc27557a2d8e5c6bca469107582082cdd53685789a46173c1e485133acbfb616ceafe7469c2e495f5a0b82f91c54bdf301d626cb41f9244248fda58ca9e93d33639f82c6706a464d1d84ae92dcddaf7ce8c8262fb2ec8ff1d376b807c0cf6affcfc6a09a109c73be274278a391ab0579346ffcf10b5d096189f450f82ef2dc563127912bdc05c228f6c86558daf7f9d29e9d7882b5bc8cfc3338bf30d47c726cdcaa1217da34e168a5f32c9cff46ebd8bd25480cc7f06c2f72906b584ea17bb850285f136c3bdf16240118ffcdb1e3774e1fd26a31217e5a0a7dbad25c95b8f42b26d75b7a08abbca30a4257dfa8f3abecb9a02c4bb58f8c14150d65b0a5c3608e70916aef5dd03ba36ad15d0b9fb7b1d832d6695c91ea0963135fc26fe38c9f84d83148195b214e157c4106a0a3c2c2bd0de6d9373372ba2a9dea4b021c200bef9eb54eedb91c0b817e6577a2a1fcfebb824c5777330e075b6114ac4986947a242423bd996a71fef632da53c07bec07ee7ff5f5808ffddcfce9745cb14e74fc4af0a34b1ff9cad02d0bb1b8057e5ff714e49b29a452c45d888dff04b988ef047b658eae01482a649c80a8111628829d00bd9f09f57e46cf682f4084b23a22d0437257015cd68004e95768302e0d7113e189dfb7da1f335d534cba93f7a011b3887fc83dfa5940d9948c7092f86dcdd3862db54f77c02d36474af5db525efc119468aeb43ea53b32d7140f382f5bdb5354ccdbb61570529e23917c3870d9bb3a1e14e56fe84a958dd15ec04ed0390ce4421285cf2e3e7e7390a90f1d4b60ae38aacb18f0cb2dca439282222f8d5e3e3b3b0dfd71b9f4dbc778ff032f16911bfbbd94a33e3e3b416b628096e89069ce62f1f448c77f09b49ef14eb52e89db856d639a37ee92758c8b758367e43aa4e6ebb634e4b4542bae596c9c4a95274a586b15b67f88fe1489bed3b30fdad8a2c943f95fc2c3959ff9aedf7ae61401c3dcb9fa5df20dbb49090e28255ada34cdee3ed74bc6c34abe59e36206d9fb912f556be781eec4b5a5080d487dc410aab373acfb11c0d46702c648b4b0bbced4d5484d5f74c26c3c01524b41f34d78396aa597675c493ffe5fc5cd90123b72216cb02f292dfa0583a092a5385ae0979946149dc44da45c384b9abfb7a0d0bd63c2649464391aa7b6fb021df592a6ccc3eefc8bd88ba1c8250d3f8a781c6f7b9adf1acc7cc482171057a1d9ba391abf1dac087cb5b55c8e783cffe23296f731dbb286c6df7f8ed66f3111823ec8ac61144adbe2ef8e887f5d592d3c491e71b45f83c068cde48e3269485b0b4241ec4a90811329e14f07141176c8710b82410c9b1261759903ca176bb8eb6bd56e224f231da671ba34332f900515f2d0689a5f34f974e2f53256a9b7b15904c19b2434df88c72db9048115223179808e62f2cdbc3a00dca22942e12abc4abf98c89ff92339a1a5f9cc5a6e1954dbd38fbfb29f4a0226d0e462685ff9adde23bbccc5a0b0d8ef5b5b6665ea57009efa3db579c79de99f263b39964decbd48b3d6b13cd8eab623e495d925884666ce139ebdf5b5686d526ae10911af2ea571bc8265a26fae2b56e832d84aa2602b59b20fb9b87de8941500a11432786da28495bc9775c63b69fca5c80bfba7e5eb9e5b52f01ae14ba60bab11772d3847bb5102a93ae498a2885094e69dc7f0b8bdc3ec65e78f5aec7795f9078d4bfb66fe269282407c261f86120a1d2864245895782730aab9baa7e67bd7a993a5608e0148afb1a1fa3d6434707d022cea251e9eca2045af34e761b30ba207f03e07ae368ecae9e25243e9530cfc244216931d3c210878b8d613b7647123e70d9b69986bed16864ac33af7088eeebb41a1dbccee68d7b93f368ace3cef49532aaf4059d3007dff749875d160f9d12b14535b417dc2eddf7721171eed8bb1f6838921e84adcc4c6f651f692fb2ba0c87c37a2e5db768aa5e97a290a8144513b9b90c16bac859b8b6cd3d60cf92324d4fab48b02825e34207aa8bdbfc50bac275aab99d69823ade7ed798a8de2137d41892bc01bd0b1812f46d81c69e9ce6321645e275697e5e008f0ab58171cde186a81b27caaf88ea6d3b501a43c8a8d44f55fe8f8e8774cde6b9e5e32045a2ccf5c4749a6ae1979215e0b3e4f18de69d20eb41d723053b27c5e2da70df6b0068ac24e47b7ae4803023ef55201572133f95d4802a8f7839aaf776a8667dcb0e0d12c2fc62f5677e718d0a2ceb941cb7d83b767ec6c84992ceb918782093ad472262aaf0084fac94bbc2f14c03d39fb05fdd8e0fd1d84a7ecd18d0a122345ab42a02d4f907a21d13d8569c60510da68a6286cba9616890b927f7f496f215d9164e6263ebc543bb0241988966f99f516d8621b2a345d4fe8fe2866e4e0aca32292868b5aec5a154f6aaf5f785cbcd1f42ea59cbcfa739fcf5af9b68dce666679434d6a7a25d9cd94f1fda2665d4c9a5d7e7c2927fc7e8d0acdbbf5fdbf530763a30631c2d8cc02c9ae7d44a92de8a0021c1df8bd02802113a5e7a6efa39c4f3ae622d59c37ebb69fa3d7a913c766ef0fe6c54b18ac4fda8006f89f45de3be28d8ecc8222b026cb69d3df472f7e097a591c193e8cd9083664d9287063158e79ceadf485c0d23d6ec998a756cf2788de548cd9d5ddb0eea21120f07d1a48548671a67dac44569ca4656e096b52b4356b9d7ee986c48d2f38a3c338f758b4c536261d38ec858a1711f5df3b5a7c40cedf51542e7e75cb91929e014940cfab2346fc03534afb6a09fe05b8a2b9cd10d0282acf8de0464efeae8d4aaeb06d73268f48db08f0f0afaba3a8397c9a559cf03470bd6fa475ea36a1cc12f9c77a132ba986c6ee6980f93863e5ec9f5eeefb77798a48c1c8b6431eb5a19244fae3da7fbca324e8b8cc572920993b264246ca6e88b72767eb57f175a3039dd3c292b9559ec75c0693674f652c826783963a8edae719ca22e1ff22d5111053244a08d145c1c17d56b5c99e4a42e14adab9008cc0143be23c0ac17e68172d19253d655bcecae6910f8182ac1e4b5e505a9bbaf8eeedb2c66574290674000e3134d11c4125561bc85fd23cbad8fce87a44313e0fa0569de19390fc7d5be8a885f4bdcda3f2f3bd2e1e1689e3aa38129fe61c38138d9a0d366d7667db2a5dce16ef8b1c0f3672c9f874b7e67d10510a57861eaf0233d60f6246b10c2f03b039277b1cd75e6a2330d29d806a111a54be860d4bc3aef6cecb3ffe3fd95afb6f0c2bfd12d43a2fb237544dc4f406da1d65d6315cab52c0270b33d8b57eb4b0b8f72d688990666058bae709ee2c667df3eabec62ef975d8ac6e03bb06accf9c63a9eb5a1d2cb4447f659c9d2fc5b8f38439ca576dc1464b971d82c8edb2ce7e2478d0498cd4166363db7aeed5b406c93705f3da6c4b69fb35b7e602adec42957e9ba0fa7b16d14793ca6ca2584056b5a12099e2a28271ae146ffa23de8433ba9c3a94a687f8877de12077acfc289aaf56923c4e3f10707ac9ec622ce23c3d57f17025a5df59fed483df48b20f67460ef2974c4c105da5cef288c67b244afa7460f9674f4ef09169664f21465ab0879e9302345e81bd290ba31418b0d9485567d68de49824f91c5cd7480e3a5167d2107304c98987a50d27a7729dd0a8f2a1ec98a4f4a3ea16d9d87908ab1ee24fa426d15363d5c986a2a6e2d8ded943aa1a2dd188795959ac5b97cf636194ad558ac51be65892e2cc18eb82494f2a02530875e477150992d3ce14a66f44e32236cabeb1d38539bf6a2147d7c70882a5553240429dad966bf6a358c8b528e41d21d559a1ca47d6222e9d7c75db209a0648cf08c8b565f322ef4becfae5df31186d2a1d5552b1e73180119ad75b6a7ebe8e0612b8ff5a85d78e4bbd5f811cf7c10ab55951ddb9b2d88e5675b947d94615fc1dd8267447f7a5e778de0d518fe901492cdc54be0c9cf3986c15d18dcbd3ec01aaebc8221ffe2537419fc92fac2de2aff6b1a37a9942c3833e5c7c4c023840a9fc50dcaa27cd0570463a4ef9fe73192285bb122c5215db3a2a7a214a351cc935294954a15095b7a50bb28f44e406893940a268d36656c4c95c6f7bd5ab4770b078a211c89d6f629a645b981a42fc79c9faafe7a9604928f61e8d3757435cc30e48c3cf554d68aea8eba582834f95d278b1255fc27e176d323f0b836f7bed7a1684cd9e20596dd7293eb8d8d051beb6d00f350aaec6d5f99c4e45c5f9adda104f3f4a2f6517a8ebdd8c74d55b2baff86386387abf660227341fc50f018d7f15e4f9b09260ba79daad3983b27fadfc6abbc5847e89bdf7091d2e856284356a7bc23baf53eee943fd577bb88036bf14837e1e7d85734abbb59506f291802cc2e25bdeded898d3afa6b1332cdf78d3fc45bcd89d4a43d25e8935648484b348aa632b9a7d2d10e2017a56f5568cb247a1b92b0727d18c04b0a29cd9f6c2f5d15bc4bdfa3bbf51938da27e936c056e32cb953f00d9312432ee5fbf31b319a4c3cbb102da85053fb6bc7a712cca55925d8149e2ea6a66dde183f2a3a08907dd6c66dc9e577ff081ba98255362ef058a1005af186d5928025569d394fbf407fe58fccea8f9b11c83a1da2f8cabe9af0deeaec5bce5e50626c6e49f7b4eceae4f36424e74aeae37212f23872743a72b1a55224a9251587da46c4de98b76396a4a22b8a61a4e4ee5768c39f89bc7fc9bc4b46c6665cb34138e91f6961b4889902910f9b04791e0204f1bd30c37fa99b2c1800025152c98792e3e3e263084b4173f19d2120e19ec8979090cdde8247c6c592f577156835e84e9f82edeebe3d16b26260e55c06485f543ade58bbbcbc4bb07ef4cb5c63ba639782b097022d5d17e7b5bf56ccb8da95d1a2d213dd772322972b8de05dea020976743fa97b17291dcd05ceb5228498e0fc88127581278881541a2990e3ddff07da7e4f918f88d6cd456eadb40245fcac7cab636cbe788b588de6a20ac66f79bc7c89f1177a8f7544fbeadf86cde6a74245ddd6c86d1801a4c2556813bdc8ad92a10c3ea89ec2cfceba44b7b55c77f72d1fa120c939caae6fd0ff06a2c42e61573dcf71d7827d942feafcb10f0b779fb008b11a11c8909d0a5ab38b8d9bd8d4ce644cd9a3990189bccb2e6794f1de14f7fda265b2ef8933d7af423634f16e446d81302991bd9962c67de1bb911c0172f9607824dc8e1f54616fa877b2076112746284ac5b4f611c3e1dc7b3247e5790e92127073692bdfd6d78f1ef7879773f9f1649907565ed13f4d41ef69c0675ef9ce0150f2d866430e4ee3a5d17e968e9fa07e66ca7e9a33b325dc9ae305b39f26f9a4ebeded620034a9dc7a7981e2031b4c5f76304bd74b94c18583a495be03918c06d9d9313da84767590d50e73f4ee3268ab64e85317ca08e3a9418b3d911699e1f2e07c2c0ff6e217e188ebe4868d3885f1b2d0ffc7967dc7eca9ee4758d476b38bf6ad7956904aea69064b8d2f032209aed3ccdd26aa04356fd9eaa747ab7a5c0726f98df167f37c496fba44b5f442376b7534072818c5b72a9d8e3f47ae35bd504fc7c133c338bedc353ea988e361ff95e1989261b77f8b55248351e13f1dc1923e81a6e34a33b88b06e6b8c259cfaf46b8ffa49e56f162fe3a844b40e2f8f8c9e22ebe57f33c0e37158f5d7952f32dfa0016533ba8365267b5a6c522c6342c8256f245648525f3a9d48859f65efff4ec497b1a2d04711dbda90075694620fe85f20fdd23e435c82d4189924652d0364568d7cfaba60e3ec7eda7ddac97579e82d004b120c30f0cb7eabe31beb7705a90051d8cd86197b3fca19aa0358b6d16447dadb021a72cc374f6c683bcc9c475010acf8cfb11bb7a5d5d516bc43357e82aab8cab8341fc27aa3811960ff47289719e3985187199984d425c28eb405598989888d38f93395b5185410fffc3712b081ba86c2844c7b68a1b6175a8aa5cf2e57c4c97e9c670ad7cace27f74f321673ad3c2760448ac662947025f882fc51b58dabdd2921ac3d063ba775105c1671e092ca2b8ed16b6e995db43c2fa21f48d0524b350863ae7f438084de007e51df41229e3ccd716b211c6a4b7bcb73d5d2e149bb225cf10badebf35df77312b329774d000b9d2a2eccfa9cf6007a45d4c3b819062db180abdfea533f8eaa3e0ecbf3dce4a50873465537d197eb553e8cfa3d533326b0b95640b5b7ab469ba5987b543e8b3728e869633b56c8a57a450516821d99d4f6a84af4e757cda908002ef12799082ed64cab7cd1d65c20bbc5160f623dfd403c2cca1347e038a20681da3e3ce6bb3ccc0bc261158b5ae20d725d8c0158ce12a98552fb6265f8d5938e8edf92c15c8d337d825f5e2658cc17b9ae3a940300a73dc9e409ce9da8f8761e3ed0a03356a25bc0510b082199778d794bb5a3d46f6143e90cf2e06f009c43f8e1b046e58184361b6e599b0115a587427b1125d3e7f05211875711f0a33e501f136c1637267a2a65bdac26f8d0d30ebc31d731750f78a62e712e9640c55adfba9662aae9f203d23e6f301aafe00f8141d7d15b2ff0e2d56bb7349922a2e75d4db31d081df833f0b13d79b6d0765087b5bc0f181fc63df264b480362097aaeb4aa964093d5933543c62b616c28fa3c8f5be33e3f7466251fb280d1b7c70cefc7e091023488c7e57d07d60393c6033a811270282a170d90d637d3f3062d190d31bd57e113c7a132a920a14420f35b2222d0370666f970323e0bdddc9079ff011f9d22ff3e2d5cbbdf777e9aff58a171ffa5a169472bf91addb0fa94c24d4bce764adf6ac58431d69c071857f97503a57b2138cd7aa3edceb07186cbfdfa59ad8074d681b104855eaa28267ab4f57fd6c28e32b39894c83bfbe14b5cefc7f76ce01616432090ab4d278d23552733df9ab4b483d81f08f176e7a66081ba0ea6ecb6d9d73c581c5aa44019c3f1d7c4c9c39f541bd4a8a6ee810b041873f08101afd115ade26ae8cac31d058ac036af6162c24ef19afe4a5e9d21ec21034007eef7945579d1ee8f56f89c8ae884dc46d95f0bcc599029242dad277b98381c01f60338f99e748e4cb37d7c108d48aaaa2680d238faec3fd4baeed0774ceac86021ef8ce746d745d8a37c05695bd0392126ffb0860c4ecc807f7dc3d7462876979a53f046be7a752d6b316fc69c8d2405305859bd29d27572be4ea328aa4d1b4f9af0287ac7966c8da62c94eeafeecf4755600973b35126e8052b1894da0d2a04084ba548277159e7a280fcb84007f4dfdb510c327c58482899cb0a35d84d58de12ec9acdf008fdec1cc5efa097f7b954c05d6f7c6a9d3cfbc972e4cc4066d5fca748fe7eda679aeb194418b2262910c21373b0a393fff178d38491896600b801013d7bb370cb7cff11583636851852abffa70660d8c0a59e4a66847ea595263b5259bde16a2a6f27c7627b8d6fd6f9ef2428d9ce42c85fb878364b96cbdea3f5fd2c1563aa00cc519ace55f6a2b95a50a9995511b9e818082df8be5e57aabca42e1e2c65ccb61e9ef9093a3a9d8cfc87a55eacfdeb0feb2e1cde384155f3a55517d16f7f600cdc06c68199dcde16af0fa46064535cdb81d0f8f8812402bc4e5d5f4e79d002327d6e37017e5c17142038f98d16a3d114731a9b1ae040ae7c92a2e32b849d6a739968d2a51ca8d78125ae3fc9ec741e57c4ce4e8401ad87e7b190d7e29ce341db25e3177e6cb8d746ae9c4d9674c75d32c68b194da8e1ee99cf7ef80fc867e4440fc6ce6e262538d554b99f78fa67bf97fd1a45d8c677b2af50910b02f21afefa4e3ae5a5e9552150c985b0205dceda957a92c7a1997b9a5b5eb339a9c83ae4ae504a2d0993a236ab027678e3505cbac512b2144b8bb535926722d71465b242384d8f845990c835ff378742aca47bc9aedfc5502a8074b9c573320802be130e4f1ef3fa1a7a4a5a800f0134f3657c0e1b0d6c7d5404dffb7d5c4355bc352b91f49207c359055f9408c80d94bb30cf0da88444df169bc38563c6cc3ec8137c8e259db9c10ff2a64aee4a294b8d2c4dc5acc1ef3c6009106e5e965ee50efc83d7cdf2169e8736b111c486f322becb329c5af4fe4d314650107f1fcc6d230fd3a978ccba28de0fee9140af4383ef493299e3c294562b94a9240adcd6088dcb922276439d77a8f25efdae9bb52e952eeac87d912d2c36767210e6439adf3e7649f1ecbfd645164ff2098e939b91795c2fdcd880365f747708dc67f868460e700726109139d03afd096885e156eef8400cd1668fcb4b0e942275c76819306f6a54cd4b2540faf3a9d59bb90fb95a84efe1e5f463fb7ab3159ffc0729d13d2f647daffcf724e9139bc37d8537beaafb5bec591658a8c1568639ccb9426c03c0f5af2bfaefa8c8d57066f85a0ec959a0afac7ba06be9ab0a68a025c96244ef1860fafaade9edc1e661a6ecfc207861789a845a98f9b18865e20b96bf057537d7f3ab03a2132c4b9e33c571ea850ef4e01ffb1cfd0d1d117d7383a399e2a3f0bdb3c5183bb7412dcab8b7174a99bc5b6dd72253a24bec2cc384ca4098d611c58cbc10a712ee9cb4e4741ec4c9ca03a8fe8a711672577a900fffc2e57ea451dc6d3077adcbbf5501537616712ef9db23567fb12c6e4ccdaf92a8a8818ecbd82c21c6102ef5ab271de324276871c6d665dbd5078f99ae2912a3b125ad813ca577d6438ea883d9bcf43a6cabded9ad9b11017fc0663b21a6009caceb9fccb9c553411a82e41e137527fc0a3f51352b89609c897d145c2456847ff7756696e40df3a6f160ade7a7f21958d3e15a853069dcc254578c8cf80649f1fca7b3a93ce933ea77292476daf2967b970a2ef9374d242054a7548fe7ab5a571debb70515a065369914d98a327eaf83eb911ccb6fe032a3212626b49499309e20ba48a39afd8313c319f7839ad6b3c45d35d0c2833be72c171edc8eb1ba5c431217a62187d5b322c1cfcb205a37b399514d1ab34cd7a5baae735277e8cf4d810bc1677764b3b222a6da3650a3a5aaeea80f06a05d551e0a2ded4c8c5ba1220546169e58caf34122c70724f89826670127fbf69ac7bd1dd81a515cf2eb4764dc80d984623ae9700b65185a8c6d2dfae2d776ac9129bdfe4317cdaec6fbe5a5998081822bdc13a0639155fc65697dc99a55207f564129f49cb27fb1f376d9c4eafe460a8cf946e8c3b535d036dc11d74b759bb7ab5cb97d38e4d46f0d0e471ab7ad7af49915b30807e97ec04add7544b29f49e6134008e1b371ad5b28a0d334c8911798cd4754ba3c1b8c37f9b123502e6fd4d41b451f14cf6f83008fb4edbf0123a58a5793b1384abd32f9b5fda1c87cd4f26188efc5951da1d9cfe6a5223d2745854c1fa1ee13b12d878a592d482f47edca1e6a499a31cfe70692bad196d4c0ab4ee2749855ef1366ae62d2070452f7bac9bd5935f9521ada97dea40383ed49c56e477efab3b14e4fbc6440c0f5ee853e1cbe628a4c300ec5a6a9f2de073dad7d9069d5744f26b8c6150f7dbbab7bdc141a03b78d02c64632b9136f0e5a450e15a7464d525d7c7bb26162a6d166fdc0145921c2499f3f200d6acc47b7b5f1a7cfabd53c4a2d01f225d09c50ba1107a2595d00ada2fd0c37906dbc4b8241e78b9fb58db47a5f1e2df94bd91c57f3f2648792ecd6fa7b9d1a019d95087ab8de8a9ab47e9c4971ad7db4f6d3157bda1d0093a15e8677a8148f77098328318107b7c1d640c1ea448a745b16f7f2dbc663cc4243454635b9fcbf7b510dbc2d13608ddc16d421863fb1654361d1bfc0f3f85744c5ed5870085c0fe532518e39abd62d8ad4d06de555e482b64f3bb0f1dbac05c6c4a52e79caf7964e011835e33444ca0357738f5bc74f8e7c1e4f509950e0011ae4435ae8479a516e5faf86273a06a99e4e78c798b43d3f328137ed6acd9bcb8f22c5694f79322d9b53ef463c81d2bce01ef104be19c74442b8e823675069c0cbca56cdc86315f588c8e17755e6c5b3650bdd55134d04be77f8e9f0273d7401bd5bef3123f6ffeec1336f0f12ce7a3adc6ea20cd9bb36bcb11d89038e96b45aeb4b65e4b3227d612a95e7fbcda71d587bc67a4f0f3f4e80284472decd1f226874d52cb8a3f227278b236f440807512a31a9c2f353d5b2f682fdcd5d9c3de9add0fa65228a42db5499cdf129ca471bcc61b7bb31f2238128352515711346e2b087a87335dcbffdcf57fe555df23eb478b4c68b8b915571aecdf209b553035ef1839a6ffa5729188b6c1c02322c83a7a20ade8e74d76dc0353b6d7943580e88a6dd63c68b4d62fed2e673eb18839c6fa0a5cb6ba2cc8e2d721b62301d04fda033cd725253e0d9222659d6962ffff890059496f244822f8de2618765c271bc05d9a8eca20e404b2f7986bdb681ab99e964face29263847e190e3ca5aa4d0806a9324d581b094cd3bb5e4ad43d2e2865a527f692545780aab0a1ca94653e13887d63294698b18dea0ae38a1f75a915f9a9082de54fcdc15a922895ad284fe245d175dc6181a7493fabac3172c053e7d64a192debc7122e0fb5149a1edbea2913df05e3ce53f4542f59e26ec6bad4dd64f87d9ebfa690455c280febac0ba5adf67e12c18fcec9abeda2a01d81426e5cee4f1b4891b1db07cfc4ad2cb1a9ef5add188e4ee2e8b0e4d68dae38abbb26b2ebe33c634df850daac14eab78a10a625013fb3be6662548fc6b362506de3080ecf5a35ac0257b0bdc199f152f31865980e8be2aeb97d0096143af2e3c23e10b05d93bc73c15ba1e1a8827450708dda15d9d868cd8d9df1e08d98084b56f87742c8e16c6e5801c57d0513dda1e477559d0639ecfdff7b0b5c4b35815e986d8d3412eacdf7293047af5e89410c2140ded427bdaa206c7b82b48ba66d800f83b7cd1b9bea0705cb597c44e4feeb9fd937e8b7db2c966bc3c22b3d297c16cb777b8bd3b834cc0a48153031e5c212ae4e3131e053efddbc7b7d3ca2b8c8df6a52c143dd512277eb6a86fff1ce40bb938ccb654a0e28c0a770438dc4a0f926ca9250e19051dc759dfe84623d987de1621b995f9b5546043dc92e6f9c377a52982aa5f89763bcab5ba528a091b03b0621645451441c8d6ce62d97f0094d688b14ef5d0e0a01a0167eb55839f0100d95dba2831045f5b2a864eba2970406a49452a9755b7238a1051eea37ab84464f1b61bd522a908b5c8bb288843fe0c9585f32e7c2b1f59e143f67ebbd66255545c30402b68285aa99345d99bc5baa13e688d4dd5d1263723c51a24b79d6d833fa68eb12e7caefc3f8703fd099dffb2e68517134416904240d9e44b99bbf8c4f4e3fbcf911170a9a9c322563bf2c3ba112120be1876e125570ac8cce16a28ea30ab44e0920372d37d6c97d06dfd87a921397ea76e5ed47d7fb1b739e35c78b4c1b9c5f56af9f7a86320c5007e4757e3f0c7910a9a6783d026ec947571b504f1208530d2ec9905c4cb6543dcfa34392e226ad5cedfed06ee99e13d875f8c228bf8aaa92aa041e92491171b77180be50b27855c842db1803800afb244326cb83f56ff599b7b5795107f1c63cecdb74e90937fd229c8d267a8cc9a8d29533e7e7f0163d20fb4fac203496631f1fab91ce6cbb82f5b90e6f425de9993dc64e50ac546b1dfade6e84ad9fa1002f4ed03ee49d48f90c01cf664c0154038fd0f003cf11a750c22eafefffa09a7a60c1a3057051e06e3ad453825f366083524e9c063777911aad05004148b515904ddd77dfdb48e5b2ed78c7ea31dbbe16dfb189ae85de0997ee65251d59e0b107746ce19e15f8f68df09a9002359a35744bf589a811b4a20bc521e1017924e30ac921de7d938c12dd1c3c02e26703d923cad145f9e5f0cd79a7be4edffdc1829f0934a18d8283d113beadd4b08c8209f39bbb6fb165e221e3099d8299e947af8623ab4326bb56e8d207da4aaeb2ffe7d6fd34e39a40be185222e60c67a4f464dffc1b3f9608667415366739e54bb280e67d68fc12fc32939d48b464a6d09b38a757679b2e2f91e684106fc541d83b9d0e5427db3e9d9380c97ac84c251ed1724561c63afcdef9ba546378ed0218e672e984adcd1fcb75c3ea8814b3a8ad62475d6a2d384b1ef643e95330cdb416782de7999a42a3aca55592bfa95602efac199f3a3417deb3941413b5cada41a2dea8fb8c6e122039efe0fa809ebbbe8daa2dc9993414b19e934a7e95db48726ab56227e15c71432ae50a9242f1fc28daf18d4f3254a95b6a164eedede1a425b18ea0c628088641bc57b0b6eceed6ba276f4ef9a4953d2dda76f48e3826a606a7388c73dfb1f48c9657fc0f27ab29d5e5bcfdbc1383729257a6ac694820c553cff322074a3086a578ac5ab6c820e6db0c74874929bff1006a38cf614e5b1cd3063d985c0f93cfa5919569123a7b351cf9d1c929f188896fe34cd36398690ab465059f7d21e867747c1d308b134a1efa43bca4d0c7332c8aedd80e2895a8e28c5250556348ba4aace75ad6f3c4c671f26f960d572c4491bc5a1f16128484ae3a0e6b08585d5fec62eac1e279e7c279a40eec7ec64bee69ee967f4c605210a9947ea23ab4624541fb42a2d2d098af0429068d666077104475c860d914c926350d7dfa6325d8c755bbf643e38bfdec8807dba4a8577d4ac9139aff7d0df1c0245d97a1855243c1e617daf9e48f000d01a141976d28db8a22600b610dd5540332548199642c4dddb362f6a9cd20cee208f0fac62078c285995a355100ef2a3c78e668f569a4b4b4306fd33e955a6e1ae180a0c0addd9f55a599c5cbe0160a4850f98f63e0a7b34a761e48159add9651db176cf73e531a56f991027de929b8e20854db85a71fb45ca758c8380898f4fb5b1d6abc191210f311a77c6dac649abcecf783873a16a0dad08011d85025a4d1ef5a16f011f67e2945712d200488a5d656269328b083082f38af16d8bd56cf8ff2dedd9cde2dfc07653b07e13163651f3293acdd718e5bddce9b440252e984cfcb3899bfb723c99bb5ddf1077fe70a4cbaa12a57c1e383e5668e0a967973e28a4425c018547a16617dedf5a8ab75c6a19c0de752560e3cde03f2fcee49d97db0fd16a2f2b64f313e204cfa3f07f955f4f38e9f666dc7df2bab01091a20c3e1c6d8ac4554cc67ed40a587bc3f59088214241e5b4963bd56c52009b221861d8daf7305fd6bff7930828bd5e26b56f9d459fcc0712b4e45b4ec36295cc2d104840031b658f0ca5d6aa474b5741947f7cdf7b0e9f66cf189b45dabff184ffb30a16c8be987fb270cc07f1d234ab86dbeada7881aa31414aa6bf5ca4b1147186b9069d6e4bf3e72dacf27d9413869bb7caca796e8c9e0316d0dd3709832d59cab96e03078c28068e06fd3753839b7bd3a5b26fdb4ecef932b8355cb88b32f8e430513476c15b8509e5dfbbc0f4788fa8dbcbb0eb106ebe2d1f173d03a89ffd10438580fc7196b15a72ca6e1819b8b85e6b73bc5f378dfbf8f9c8d5f69a871ddc52bfef930225fff7184b7764f9154ac389360b79563847cf964d09fa564fa51383c7101858f74180b5f260aa47ddf98e1d85a4ff304aac730091bc3924877ada8a9d19f40eef7bf765e6d8b33b276c45331ce44ed61bb389a5097a7af89454a0842a2be13e9017579f180071c1a030b993964e3989ac47025634a5c56110afbd434230ea72758998f9e84d6dfad9c656ffbb13d113d53b29d3e52255376a01d726e79e502bb3950d366b98e1d83f10b066d14230af078905a037b81c757c096705ea0634b64cf01e5029769d3f044fad8128aa7a083757480b34e72d3534b790d8e9b370414d2b7eef2d5b2cfb4dade0a1ba12bf8fe1dae5cb2e8a15335d52defd57997e568a0aa0c2c2f30622e4731f3bac5b8a9c8e324029eeca5832b1309a7608c11f592297d1503a7e2c34982661d85d8f712a63752df7eb1d076e9315e54f26bd99bb87ec8009bb3e516b90e8e4b13452d46329edfe2646f63a74f6761ff5d5b368303dd56ddcf7fb573ae7a5fefb7761b2016d53c6d79c576384f184e8ec2dd461fd62ffe7ac0463bf99366bed9acde618b8faab17b1b9ec8556c25b8fe875c0ffbc72b24e762eb22d7fb49535031541d7a5ef76befdaf31752cba2b3355c35f29173b93071aabeead5d84f23e5dc7f7f5ffb9f778f1a833209ae85384ec272b760c881a5000cb5c3f1d70d28d40734bee81107504d897855c9a09ed619aa8972db45b72e146ddd3e45ee2757a6d8fe0526087dd05f56a18c24d1cf61d25d737bbe1b459c682986c5a1b799764f091be983e91b41876642ecffdfdeca709e469454b0b32f7f69df76c1ffeffade7e5027db957866e4fb62a2790c45a607806f13ffa5cf4120d4b791106a01636c5a1726fd8fa16e448e3f514299bdb62690f6c7824609efb5a92f4de9a77460ba4b5984ce43d5dd1f3ece965b6877bc4d1d9af937156fa6450aa74747168685b4016c3cd138fbf6df6c002b5b2a8a75323b10060b69193230d3b83d2687aa8417fc3365fc0b4a2098c6247e44382a45942e43312c03ad4e820d11a3335579ad741ffdd80631ed883f5daab32f8bf17ac9090640b0c602d7dc96b0ea67136414579062515b9ef0838a18af59e9b887ac625cbe9926940e3ad8904c1bf713ef12e066e929b74d58a93b07acafee22067f45149a45ff05fecac7e96fd84d3d344ee23ad4298c9900ee2f0ccfe9165ec86d853558664bcc05366b914a7913b06a6d308b93059c78537e43893f5e69d82c0511615a28d6117d3cac472275870211d5b77f60d4bd9cd9df2dea2c004d2436a83c25cb96462a36dfc9f6b80fe3f9e04b838be663bfd15543e1e19ccd2afbd5fa12f651c08455e26dfc0e56c374a73b47de9c1ecc95e6ea419b747262cd97e948407246b9491d6bdd01db0e52577afc8cd7e207c7889465b29f19681ad18294ebaf8b28f72681442b70309f61571d84fded279f8c9759d374c0a844132a41a7b4861f59f3f3f775810b5082db8febe711809dfe55d63b00107792a5e47292588851236ae69ee0fae4f5c1027afcd4d12931bb5509ec1bf2f82dd4b4935224c729f273dccd00373d15a5e97ac5eb0ffa69d591f51b9a0c44ff1180d5f5a5df95118d02d2e45487b206f14922363df7b27c3dfbe5485b6c00a71d3441c75d41f34454c2fe49899be58e230a6a819543d33f0d121ae145584490b5d7809110b0a06f2a6bf845e5240f57b342d0b5fe97832b9a597d385ebbbde43043b56b72664beebccef1c8ff431b0a59ff2c747219d34fd2428a2669a31f5251139c226d9d76753a47d5cf9fd6f9a5564d76318af97677aae6f5d1875035b946883b2a9d327862779f6aa98044640b09b0cce83d51b7548aa838a46ab4fa965f5becb82f7da1c0f9c8ea40ab4752873a87a173f510b6e1a8cd9fb49abd14bf787787deaf56f2aee49448e56ba6d6ad2d6b30ac0d1e2122e3fc75fab9f7c331be042158f698b9e22308fb1482dda9748eaaaf26d43d7c41348915aacf26098855c83cdfa60e66f16ca937a3495b3efc39b4c5ebea9a635322c4857ca6589757d082ca611432459337286c379980be588b6eb80d0a4eb58f5d401d8e051102bf050dc3d99d63077ad44de13f52558b64ffc1f473f70cdd45d314ec03c56872ca1d354de8b37aef7629c135ced3e3c020e25ebfae62e55f232f1832f5ec6f061b43e95894ed6b2959b1d5fa82e16c3ce13a4bc2d21d367c9d6526a5fa8f1c2634974bc99a467e3ec250402e8a9a3f70dea63bf3a87287b0d9f75435d1312a634a8dde684b9b68102b602b3102aca0b5f2eb8881066c016c3fbc5faadcdfb6c2e5af0ed62a8afe756503dddc531fda3c073e1ba83a656529fb196277838d9a72efcf943dd55f899b4d6961e2c54243e8924a0efcf42063179aeb1caf5231d93c984c79b2e197cfd51a1350afdf65194c980b34312c6541ef0b72304e7123e2660bfcb40af44ee86cecd521c371bd6540b6433dba82bf4797e99f5e04e4231149c6a66d42f78b411f0d0a73771e02b54b04949a1b84af14657bbc46e774c62f46038617d52680ebdc1f193d1a27dd399ec7496ee57812a1699215f1cd942bb0bd600a60398861b553af9950fae0c7469f84276c0fe7247d19c73c912e971a55260052e031e0f1a51a449dc40fc2675f6e380d53a84bd5cb8504237fcf2c2798ceff9d07cd56a86b4b3a12ca9f00777cc217df031d710d8fc2b9618dbbe520adbec6d91f3f951af54acb1eb5c1fc973ce5e2dde33819cfe8f2cae8cdf22b98027f2c2ffb80c4ff266c5aa164c75a3785317f6d7a5981008ad2faca1fd3224eab062224068b950feadd93e1868eb67bbd6fc8b96a72b6136439bb3a2d21842c458a9c6bbcaaef414d735a351a616c70c8e2d336e2adcfa47e692c9be434468c26baa0069c6c15f29b240188d8ea6a8f544eb8378876bca84fe04b813117dd5a48776091934d8db699fb500f0d746222718d68483023945eb0fbb82e2cd1df2586dc235415c9fd2e7da04a0dd52aca3bde8dc24c7a37d55a20125d3e3c62ed9605f7008b80b2aef4b5dc32627118e8ee57ca25c9da08188da8ec0d329b08850f5ebe70dceec4f76eac5286b13a70db7589125c5161e8312f3558189b203efa43f8e5760b713b99a59b07304f0288cf8da5424e5d16a1755651c16924d5cc06bfaf4180e8c661adc65c7cb686ff933a6baacb1803662fd04459a66294b2ddb695255d9b35879ef93defd23786be945eaa739dbcce942e132e93b8b58d7f56ae5e5ead3267fcb9aff6f7b502beb0015d1eb3e096f49c973e84f6c95f0d43312a820219b5774e2e679ad28b7060ad94e3492d7529a7b21184a6b11d078427d2d21fe7f104ed5a07138f64d357afae14b190af13b20cea7dcd02c1780512e5fb1d6e7cb6b54b486c0700b602fb856be46e6b51729bfa9fb228aaad1a5042cc1124f4d5e3039d97914a27ef81eb689043f70bd9a53ac14b8e2cea61d5688a7306603e9c95e3ad75e5b2e8146f511d5924d4bd4173cc1867d1d6657fecfd143df510665c8c9c758f11c65c5e62c49cc7b4df7d1934ab4a377176e571dd91599d2d5c538875f9ac</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Talk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Talk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OS】Python模拟简单的操作系统</title>
      <link href="/2023/04/27/os-python-simulate/"/>
      <url>/2023/04/27/os-python-simulate/</url>
      
        <content type="html"><![CDATA[<h1 id="【OS】Python模拟简单的操作系统"><a href="#【OS】Python模拟简单的操作系统" class="headerlink" title="【OS】Python模拟简单的操作系统"></a>【OS】Python模拟简单的操作系统</h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>学习操作系统的时候，关注的对象是：</p><ul><li>应用程序</li><li>系统调用</li><li>操作系统的内部实现</li></ul><p>通常的学习思路：</p><ul><li>真实的操作系统</li><li>编译内核环境</li><li>qemu模拟</li></ul><p>但是，换个角度想一下，把上述的思路抽象，可以使用如下的思路学习：</p><ul><li>应用程序 &#x3D;&#x3D; Python Code + Syscall</li><li>操作系统 &#x3D;&#x3D; Python Code + 假想的IO设备</li></ul><p>比如，我想要实现操作系统中的打印，可以在Python中定义<code>sys_write</code>就是通过系统调用进行输出内容的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    sys_write(<span class="string">&quot;Hello Python OS!&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h2><p>一个最基本的OS，不可能只有一个write的api吧，想一想一个最基本的OS需要什么api呢？</p><ul><li>write（输出字符）</li><li>spawn（创建一个状态）</li><li>choose（随机选择一个状态）</li><li>sched（随机切换到某个状态并且执行）</li></ul><p>如何使用Python实现上述的api呢？</p><p>部分api还是非常显而易见的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sys_write</span>(<span class="params">msg</span>):</span><br><span class="line">    <span class="built_in">print</span>(msg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sys_choose</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> randmo.choice(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sys_spawn</span>(<span class="params">x</span>):</span><br><span class="line">    running.append(x)   <span class="comment"># 状态队列</span></span><br></pre></td></tr></table></figure><p>但是sched这种如何实现呢？得切换到<code>running</code>队列中的某个状态中并且执行！同时需要注意如下几点：</p><ul><li>保存<code>当前状态</code></li><li>恢复<code>目的状态</code></li></ul><p>其实这种操作在软件层经常用到，就比如函数调用链，就需要保存当前状态，同时去执行下一个函数。</p><p>那么如何在Python Code中实现这样的操作呢？可以使用生成器模式，在函数中使用<code>yield</code>关键字让其成为一个生成器。</p><blockquote><p>Python的生成器支持<code>send</code>方法，可以让生成器变为双向通道。<code>send</code>可以把参数发送给生成器，同时让这个参数成为上一条yield表达式的求值结果，并且将生成器推进到下一条yield表达式，然后把yield右边的值返回给send方法的调用者。<br>首次调用send方法的时候只能传入<code>None</code></p></blockquote><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>结合上述的分析，我们可以用面向对象的思想写出如下的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func, *args</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.func = func(*args)</span><br><span class="line">        self.ret = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">step</span>(<span class="params">self</span>):</span><br><span class="line">        syscall, args, *_ = self.func.send(self.ret)</span><br><span class="line">        self.ret = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> syscall, args</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OS</span>:</span><br><span class="line">    SYSCALLS = (<span class="string">&quot;choose&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="string">&quot;spawn&quot;</span>, <span class="string">&quot;sched&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, src</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">vars</span> = &#123;&#125;</span><br><span class="line">        <span class="built_in">exec</span>(src, <span class="built_in">vars</span>)</span><br><span class="line">        self.main = <span class="built_in">vars</span>[<span class="string">&quot;main&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        running = [Thread(self.main)]</span><br><span class="line">        <span class="keyword">while</span> running:</span><br><span class="line">            t: Thread = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">match</span> (t := running[<span class="number">0</span>]).step():</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;choose&quot;</span>, x:  <span class="comment"># choose this and exec</span></span><br><span class="line">                        t.ret = random.choice(x)</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;write&quot;</span>, msg:</span><br><span class="line">                        <span class="built_in">print</span>(msg, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;spawn&quot;</span>, (fn, args):</span><br><span class="line">                        running.append(Thread(fn, args))</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;sched&quot;</span>, _:</span><br><span class="line">                        random.shuffle(running)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                running.remove(t)</span><br><span class="line">                random.shuffle(running)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> sys.argv.__len__() &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;python3 os_model.py [src]&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    src = <span class="built_in">open</span>(sys.argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;u8&quot;</span>).read()</span><br><span class="line">    <span class="keyword">for</span> syscall <span class="keyword">in</span> OS.SYSCALLS:</span><br><span class="line">        src = src.replace(<span class="string">f&quot;sys_<span class="subst">&#123;syscall&#125;</span>&quot;</span>, <span class="string">f&quot;yield &#x27;<span class="subst">&#123;syscall&#125;</span>&#x27;, &quot;</span>)</span><br><span class="line">    OS(src).run()</span><br></pre></td></tr></table></figure><p>稍微解释一下上述的代码：</p><ul><li>需要传入一个参数，指定需要执行的python文件</li><li>读取这个python文件的代码，将sys_write这类的syscall函数转为<code>yield</code>构造的生成器函数</li><li>使用OS类进行执行，OS在<code>__init__</code>的时候使用<code>exec</code>载入了python文件的信息</li><li>执行run函数，在每个线程的step函数执行后，执行不同的syscall函数</li><li>维护<code>running</code>线程队列</li><li>每次执行<code>sys_spawn</code>的时候会将这个函数加入到<code>running</code>队列</li><li>一个线程执行结束抛出<code>StopIteration</code>的异常，同时从<code>running</code>队列删除，在打乱线程队列</li></ul><p>那么如何使用上述的代码呢？</p><p><code>python3 os_model.py test.py</code></p><p>test.py如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Tprint</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        sys_write(<span class="string">f&#x27;#<span class="subst">&#123;count:02&#125;</span> Hello from <span class="subst">&#123;name&#125;</span><span class="subst">&#123;i+<span class="number">1</span>&#125;</span>\n&#x27;</span>)</span><br><span class="line">        sys_sched()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = sys_choose([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">    sys_write(<span class="string">f&#x27;#Thread = <span class="subst">&#123;n&#125;</span>\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> <span class="string">&#x27;ABCDE&#x27;</span>[:n]:</span><br><span class="line">        sys_spawn(Tprint, name)</span><br><span class="line">    sys_sched()</span><br></pre></td></tr></table></figure><p>上述代码执行后的效果，可以正常执行</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c73e8bb253760545eb5ff6b32cc8a3ea.png" alt="image-20230526131004022"></p><p>其实上述的模型有挺多不合理的地方：</p><ul><li>sys_sched只能由用户手动调用，而真实OS会被动调用</li><li>只有一个终端 ，同时没有stdin的输入</li><li>没有实现fork等较常用的syscall的操作</li></ul><p>但是在GitHub上有个开源的项目，使用python模拟运行一个操作系统，并且只有简短的<code>500行</code></p><p><a href="https://github.com/codebox/mosaic">codebox&#x2F;mosaic: Python script for creating photomosaic images (github.com)</a></p><h2 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h2><blockquote><p>我们可以用 “简化” 的方式把操作系统的概念用可执行模型的方式呈现出来：</p><ul><li>程序被建模为高级语言 (Python) 的执行和系统调用</li><li>系统调用的实现未必一定需要基于真实或模拟的计算机硬件</li><li>操作系统的 “行为模型” 更容易理解</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
          <category> Python </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> Python </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Talk】New Blog</title>
      <link href="/2023/04/26/new-blog/"/>
      <url>/2023/04/26/new-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="New-Blog"><a href="#New-Blog" class="headerlink" title="New Blog"></a>New Blog</h1><blockquote><p>Use Github Pages With Hexo!</p></blockquote><h2 id="Why-Hexo"><a href="#Why-Hexo" class="headerlink" title="Why Hexo?"></a>Why Hexo?</h2><p>考虑到未来某天交不起服务器的money了，于是白嫖GitHub Pages服务，这样只需要一个域名就可以看静态博客了~</p><p>考虑了挺多的静态博客框架，最后选择了比较简单的<code>Hexo</code></p><h2 id="Write-what"><a href="#Write-what" class="headerlink" title="Write what?"></a>Write what?</h2><p>目前不考虑迁移之前的博客，等到真的要迁移的那一天，再搞个自动化迁移也不迟~</p><p>从这篇文章开始，之后的博客文章将会在本站和<a href="https://www.woodwhale.top/">主站点</a>同步更新~</p>]]></content>
      
      
      <categories>
          
          <category> Talk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Talk </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
